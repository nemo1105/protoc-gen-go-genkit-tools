package main

import (
	"fmt"
	"sort"
	"strconv"
	"strings"

	pb "github.com/nemo1105/protoc-gen-go-genkit-tools/genkit/tool/v1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	opts := protogen.Options{}
	opts.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if file.Generate {
				generateFile(plugin, file)
			}
		}
		return nil
	})
}

type methodMeta struct {
	method      *protogen.Method
	toolDoc     *pb.ToolDoc
	toolName    string
	description string
	inputSchema map[string]any
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	var services []struct {
		service *protogen.Service
		methods []methodMeta
	}

	for _, s := range file.Services {
		var toolMethods []methodMeta
		for _, m := range s.Methods {
			td := getToolDoc(m.Desc)
			if td == nil {
				continue
			}
			meta := methodMeta{
				method:      m,
				toolDoc:     td,
				toolName:    deriveToolName(s, m, td),
				description: deriveDescription(m, td),
				inputSchema: buildInputSchema(m.Desc, td),
			}
			toolMethods = append(toolMethods, meta)
		}

		if len(toolMethods) > 0 {
			services = append(services, struct {
				service *protogen.Service
				methods []methodMeta
			}{service: s, methods: toolMethods})
		}
	}

	if len(services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_genkit.tools.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-go-genkit-tools. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P("package ", file.GoPackageName)
	g.P()

	g.P("import (")
	g.P(`"context"`)
	g.P(`"encoding/json"`)
	g.P(`"errors"`)
	g.P(`"fmt"`)
	g.P()
	g.P(`genkitai "github.com/firebase/genkit/go/ai"`)
	g.P(`"github.com/firebase/genkit/go/genkit"`)
	g.P(`"google.golang.org/protobuf/encoding/protojson"`)
	g.P(")")
	g.P()

	for _, svc := range services {
		writeServiceHelpers(g, svc.service, svc.methods)
	}
}

func writeServiceHelpers(g *protogen.GeneratedFile, svc *protogen.Service, methods []methodMeta) {
	implName := fmt.Sprintf("%sToolImpl", svc.GoName)

	g.P("// ", implName, " defines the methods that can be wrapped as Genkit tools.")
	g.P("type ", implName, " interface {")
	for _, m := range methods {
		g.P(m.method.GoName, "(context.Context, *", g.QualifiedGoIdent(m.method.Input.GoIdent), ") (*", g.QualifiedGoIdent(m.method.Output.GoIdent), ", error)")
	}
	g.P("}")
	g.P()

	for _, m := range methods {
		constName := toolConstName(svc, m.method)
		g.P("const ", constName, " genkitai.ToolName = ", strconv.Quote(m.toolName))
	}
	g.P()

	g.P("// Register", svc.GoName, "Tools registers all tool-enabled methods from ", svc.GoName, ".")
	g.P("func Register", svc.GoName, "Tools(g *genkit.Genkit, impl ", implName, ") ([]genkitai.Tool, error) {")
	g.P("var tools []genkitai.Tool")
	for _, m := range methods {
		funcName := defineFuncName(svc, m.method)
		g.P("if t, err := ", funcName, "(g, impl); err != nil {")
		g.P("return nil, err")
		g.P("} else {")
		g.P("tools = append(tools, t)")
		g.P("}")
	}
	g.P("return tools, nil")
	g.P("}")
	g.P()

	g.P("// Register", svc.GoName, "ToolRefs registers tools and returns ToolRef slice for ai.WithTools.")
	g.P("func Register", svc.GoName, "ToolRefs(g *genkit.Genkit, impl ", implName, ") ([]genkitai.ToolRef, error) {")
	g.P("tools, err := Register", svc.GoName, "Tools(g, impl)")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("refs := make([]genkitai.ToolRef, len(tools))")
	g.P("for i, t := range tools {")
	g.P("refs[i] = t")
	g.P("}")
	g.P("return refs, nil")
	g.P("}")
	g.P()

	for _, m := range methods {
		writeMethodHelper(g, svc, m)
	}
}

func writeMethodHelper(g *protogen.GeneratedFile, svc *protogen.Service, meta methodMeta) {
	funcName := defineFuncName(svc, meta.method)
	reqName := g.QualifiedGoIdent(meta.method.Input.GoIdent)
	respName := g.QualifiedGoIdent(meta.method.Output.GoIdent)
	coerceName := coerceFuncName(svc, meta.method)
	schemaVar := schemaVarName(svc, meta.method)

	g.P("var ", schemaVar, " = ", renderSchemaLiteral(meta.inputSchema))
	g.P()
	g.P("// ", funcName, " defines Genkit tool wrapper for ", meta.toolName)
	g.P("func ", funcName, "(g *genkit.Genkit, impl ", svc.GoName, "ToolImpl) (genkitai.Tool, error) {")
	g.P(`tool := genkit.DefineToolWithInputSchema[*`, respName, "](")
	g.P("g,")
	g.P(strconv.Quote(meta.toolName), ",")
	g.P(strconv.Quote(meta.description), ",")
	g.P(schemaVar, ",")
	g.P("func(ctx *genkitai.ToolContext, input any) (*", respName, ", error) {")
	g.P("req, err := ", coerceName, "(input)")
	g.P("if err != nil {")
	g.P("return nil, err")
	g.P("}")
	g.P("return impl.", meta.method.GoName, "(ctx, req)")
	g.P("},")
	g.P(")")
	g.P("return tool, nil")
	g.P("}")
	g.P()

	g.P("func ", coerceName, "(input any) (*", reqName, ", error) {")
	g.P("if req, ok := input.(*", reqName, "); ok {")
	g.P("return req, nil")
	g.P("}")
	g.P("if input == nil {")
	g.P("return nil, errors.New(", strconv.Quote(meta.toolName+" requires input"), ")")
	g.P("}")
	g.P("raw, err := json.Marshal(input)")
	g.P("if err != nil {")
	g.P(`return nil, fmt.Errorf("marshal `, meta.toolName, ` input: %w", err)`)
	g.P("}")
	g.P("var req ", reqName)
	g.P("if err := protojson.Unmarshal(raw, &req); err != nil {")
	g.P(`return nil, fmt.Errorf("unmarshal `, meta.toolName, ` input: %w", err)`)
	g.P("}")
	g.P("return &req, nil")
	g.P("}")
	g.P()
}

func defineFuncName(svc *protogen.Service, m *protogen.Method) string {
	return fmt.Sprintf("define%s%sTool", svc.GoName, m.GoName)
}

func coerceFuncName(svc *protogen.Service, m *protogen.Method) string {
	return fmt.Sprintf("coerce%s%sRequest", svc.GoName, m.GoName)
}

func schemaVarName(svc *protogen.Service, m *protogen.Method) string {
	return fmt.Sprintf("schema%s%s", svc.GoName, m.GoName)
}

func toolConstName(svc *protogen.Service, m *protogen.Method) string {
	return fmt.Sprintf("%s%sTool", svc.GoName, m.GoName)
}

func deriveToolName(svc *protogen.Service, m *protogen.Method, doc *pb.ToolDoc) string {
	if doc != nil && doc.GetName() != "" {
		return doc.GetName()
	}
	return strings.ToLower(svc.GoName + "_" + m.GoName)
}

func deriveDescription(m *protogen.Method, doc *pb.ToolDoc) string {
	if doc != nil && doc.GetDesc() != "" {
		return doc.GetDesc()
	}
	return fmt.Sprintf("Tool wrapper for %s", m.GoName)
}

func getToolDoc(method protoreflect.MethodDescriptor) *pb.ToolDoc {
	opts, ok := method.Options().(*descriptorpb.MethodOptions)
	if !ok || opts == nil {
		return nil
	}

	ext := proto.GetExtension(opts, pb.E_ToolDoc)
	doc, ok := ext.(*pb.ToolDoc)
	if !ok {
		return nil
	}
	return doc
}

func getFieldDoc(field protoreflect.FieldDescriptor) *pb.ToolFieldDoc {
	opts, ok := field.Options().(*descriptorpb.FieldOptions)
	if !ok || opts == nil {
		return nil
	}

	ext := proto.GetExtension(opts, pb.E_FieldDoc)
	doc, ok := ext.(*pb.ToolFieldDoc)
	if !ok {
		return nil
	}
	return doc
}

func buildInputSchema(method protoreflect.MethodDescriptor, doc *pb.ToolDoc) map[string]any {
	msg := method.Input()
	props := make(map[string]any)
	var required []string

	for i := 0; i < msg.Fields().Len(); i++ {
		field := msg.Fields().Get(i)

		prop := map[string]any{
			"type": jsonType(field.Kind()),
		}

		if fd := getFieldDoc(field); fd != nil {
			if fd.Desc != "" {
				prop["description"] = fd.Desc
			}
			if fd.Example != "" {
				prop["example"] = fd.Example
			}
			if fd.Required {
				required = append(required, string(field.Name()))
			}
		}

		props[string(field.Name())] = prop
	}

	schema := map[string]any{
		"type":       "object",
		"properties": props,
	}
	if doc != nil && doc.GetInput() != "" {
		schema["description"] = doc.GetInput()
	}
	if len(required) > 0 {
		sort.Strings(required)
		schema["required"] = required
	}

	return schema
}

func jsonType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return "boolean"
	case protoreflect.DoubleKind, protoreflect.FloatKind:
		return "number"
	case protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Sint32Kind, protoreflect.Sint64Kind,
		protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.Fixed32Kind, protoreflect.Fixed64Kind:
		return "integer"
	default:
		return "string"
	}
}

func renderSchemaLiteral(v any) string {
	switch val := v.(type) {
	case map[string]any:
		var b strings.Builder
		b.WriteString("map[string]any{")
		keys := make([]string, 0, len(val))
		for k := range val {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			if i > 0 {
				b.WriteString(" ")
			}
			b.WriteString(strconv.Quote(k))
			b.WriteString(": ")
			b.WriteString(renderSchemaLiteral(val[k]))
			b.WriteString(",")
		}
		b.WriteString("}")
		return b.String()
	case []string:
		var parts []string
		for _, s := range val {
			parts = append(parts, strconv.Quote(s))
		}
		return "[]" + "string{" + strings.Join(parts, ",") + "}"
	default:
		return fmt.Sprintf("%#v", val)
	}
}
